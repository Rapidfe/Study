## 정렬 알고리즘

### 종류

- 선택(Selection) 정렬
- 거품(Bubble) 정렬
- 삽입(Insertion) 정렬

 　 ↑↑↑ 단순 / 성능👎 ↑↑↑

 　 ↓↓↓ 복잡 / 성능👍 ↓↓↓

- 퀵(Quick) 정렬
- 합병(Merge) 정렬
- 힙(Heap) 정렬

　

### 내용 요약

#### 선택 정렬

- " 가장 작은 것을 선택해서 제일 앞으로 보내자. "

- 시간복잡도: O(N^2)

  N + (N-1) + (N-2) + … + 1　=　N*(N+1)/2　=　O(N^2)

#### 버블 정렬

- " 바로 옆과 비교해서 큰 것을 뒤로 보내자. "

　　　　　　　 　 　　(=작은 것을 앞으로 보내자.)

- 시간복잡도: O(N^2)
- ```성능👎``` 알고리즘 중에서 가장 느리다.

#### 삽입 정렬

- " 각 숫자를 적절한 위치에 삽입하자. "

- 시간복잡도: O(N^2)

- ```성능👎``` 알고리즘 중에서 가장 빠르다. 경우에 따라서 O(N)까지 빨라질 수 있기 때문.

- 구현 해 보면 버블 정렬과 비슷한 것 같은데 뭐가 다를까?

  삽입 정렬은 필요한 만큼만 동작한다.

  버블 정렬에서 swap이 더 이상 발생하지 않을 때 종료하는 조건을 추가한다면 삽입 정렬과 비슷할 것이다. 

- 다른 정렬 알고리즘과 섞어 사용되기도 한다.

  예) 퀵 정렬에서 원소의 개수가 적을 때는 삽입 정렬로 대체하기도 한다.

#### 퀵 정렬

- 분할 정복 알고리즘.

- 수 하나(Pivot)를 기준으로 이보다 작은 수와 큰 수 두 집합으로 나누고, 각각에 대해 재귀적을 반복한다. Pivot은 주로 가장 앞의 원소를 선택한다.

- 시간복잡도: O(NlogN)

  이는 평균 시간복잡도이다. 최악의 경우 O(N^2)이 될 수 있다.

- Pivot이 전체 수의 Median에서 멀어질수록 성능이 떨어진다.

  두 집합 중 하나의 집합에만 원소가 편향되어 분할 정복의 이점이 사라지기 때문.

- Pivot 선택 방법을 수정하여 최악의 경우를 피할 수 있다.

  1. 랜덤 선택

  2. 3개 원소의 Median 선택

#### 합병 정렬

- 분할 정복 알고리즘.

- 반으로 나누고 정렬하면서 합친다.

- 시간복잡도: O(NlogN)

  퀵 정렬과 달리 항상 반으로 나누기 때문에 O(NlogN)이 보장된다.

- 하지만 O(N)만큼의 메모리가 추가로 필요하다.

#### 힙 정렬

- 힙 구조를 이용.
- 다음에 정리
